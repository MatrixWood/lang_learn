# Guide to the parser

> https://devguide.python.org/internals/parser/

## 摘要

CPython中的解析器目前是一个PEG（Parsing Expression Grammar，解析表达式语法）解析器。解析器的第一个版本曾经是一个基于LL(1)的解析器，它是CPython最古老的部分之一，在被PEG解析器取代之前实现。特别是，当前的PEG解析器和旧的LL(1)解析器都是解析器生成器的输出。这意味着编写解析器的方式是将Python语言的语法描述提供给一个特殊的程序（解析器生成器），然后输出解析器。因此，改变Python语言的方式是通过修改语法文件，开发者很少需要与解析器生成器本身互动，除了使用它来生成解析器。

## PEG解析器的工作原理

PEG解析器的语法（如当前所用的）与上下文无关语法的不同之处在于，它的编写方式更紧密地反映了解析器在解析时的操作方式。一个基本的技术差异是选择操作符是有序的。这意味着在编写：

```
rule: A | B | C
```

一个上下文无关语法解析器（如LL(1)解析器）会生成构造，给定一个输入字符串，它将推断出哪个选择（A、B或C）必须被展开，而PEG解析器会检查第一个选择是否成功，只有在失败的情况下，它才会按照它们编写的顺序继续尝试第二个或第三个选择。这使得选择操作符不是可交换的。

与LL(1)解析器不同，基于PEG的解析器不能有歧义：如果一个字符串被解析，它有且只有一个有效的解析树。这意味着基于PEG的解析器不会遭受LL(1)解析器和一般上下文无关语法可能出现的歧义问题。

PEG解析器通常构建为递归下降解析器，语法中的每条规则对应于实现解析器的程序中的一个函数，解析表达式（规则的“展开”或“定义”）代表了该函数中的“代码”。每个解析函数在概念上接受一个输入字符串作为其参数，并产生以下结果之一：

- 一个“成功”结果。这个结果表明该表达式可以被该规则解析，并且该函数可以选择性地向前移动或消耗掉一个或多个提供给它的输入字符串的字符。

- 一个“失败”结果，在这种情况下不消耗任何输入。

请注意，“失败”结果并不意味着程序是不正确的，也不一定意味着解析失败。由于选择操作符是有序的，失败很多时候仅仅表示“尝试下一个选项”。直接实现为递归下降解析器的PEG解析器在最坏情况下将呈现指数时间性能，因为PEG解析器具有无限的前瞻（这意味着它们可以在决定规则之前考虑任意数量的令牌）。通常，PEG解析器通过一种称为“packrat解析”的技术避免了这种指数时间复杂性，这不仅会在解析之前将整个程序加载到内存中，而且还允许解析器任意回溯。通过记忆已经匹配的规则在每个位置上的结果来提高效率。记忆化缓存的代价是解析器将自然使用比简单的LL(1)解析器更多的内存，后者通常是基于表的。

## 核心观点

> 重要：
不要试图以同样的方式去理解PEG语法，就像你对EBNF或上下文无关语法所做的那样。PEG是为了描述输入字符串将如何被解析而优化的，而上下文无关语法是为了生成它们描述的语言的字符串而优化的（在EBNF中，要知道给定的字符串是否属于该语言，你需要做工作来找出答案，因为这并不是从语法中立即显而易见的）。

- 选择是有序的（A | B 与 B | A 不同）。
- 如果规则返回失败，并不意味着解析失败，它只是意味着“尝试其他的”。
- 默认情况下，PEG解析器以指数时间运行，可以通过使用记忆化优化为线性时间。
- 如果解析完全失败（没有规则成功解析所有输入文本），PEG解析器没有“错误在哪里”的概念。

## 有序选择操作符的后果

尽管PEG可能看起来像EBNF，但它的含义却大不相同。PEG解析器中选择是有序的这一事实（这是PEG解析器工作方式的核心）除了消除歧义外，还有深远的后果。

如果一个规则有两个选择，第一个成功了，即使调用规则未能解析剩余的输入，也不会尝试第二个选择。因此，解析器被认为是“急切的”。为了说明这一点，考虑以下两个规则（在这些例子中，一个token是一个单独的字符）：

```
first_rule:  ('a' | 'aa') 'a'
second_rule: ('aa' | 'a' ) 'a'
```

在常规的EBNF语法中，两个规则都指定了语言{aa, aaa}，但在PEG中，这两个规则中的一个接受字符串aaa但不接受字符串aa。另一个则相反——它接受字符串aa但不接受字符串aaa。规则('a'|'aa')'a'不接受aaa，因为'a'|'aa'消耗了第一个a，让规则中的最后一个a消耗了第二个，留下了第三个a。由于规则已经成功，永远不会尝试回去让'a'|'aa'尝试第二个选择。表达式('aa'|'a')'a'不接受aa，因为'aa'|'a'接受了所有的aa，没有留下什么给最后的a。同样，'aa'|'a'的第二个选择也没有尝试。

> 警告：
有序选择的效果，如上所示，可能被许多层次的规则隐藏。

因此，编写规则时，一个选择包含在下一个选择中，在几乎所有情况下都是一个错误，例如：

```
my_rule:
    | 'if' expression 'then' block
    | 'if' expression 'then' block 'else' block
```

在这个例子中，第二个选择永远不会被尝试，因为第一个选择会首先成功（即使输入字符串后面有一个'else'块）。要正确编写这个规则，你可以简单地改变顺序：

```
my_rule:
    | 'if' expression 'then' block 'else' block
    | 'if' expression 'then' block
```

在这种情况下，如果输入字符串没有'else'块，第一个选择将失败，第二个选择将在没有该部分的情况下被尝试。















