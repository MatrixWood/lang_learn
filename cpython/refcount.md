include/refcount.h 定义了对象的引用计数机制。引用计数是Python内存管理的核心，用于跟踪对象被引用的次数，以便在不再有引用指向对象时自动释放内存。

代码中定义了多个宏和内联函数，用于操作对象的引用计数。这些操作包括增加引用计数（`Py_INCREF`）、减少引用计数（`Py_DECREF`）、设置引用计数（`Py_SET_REFCNT`）以及检查对象是否为“不朽”对象（`_Py_IsImmortal`）。

不朽对象是指其引用计数被设置为一个特殊值，使得它们不会被自动销毁。这通常用于静态分配的对象或者在运行时被标记为不朽的对象。

代码还考虑了不同的系统架构（32位和64位）以及是否启用了全局解释器锁（GIL）。在没有GIL的情况下，引用计数的操作需要是原子的，以避免多线程环境中的竞态条件。

此外，代码还处理了引用计数可能溢出的情况，通过饱和算术来避免引用计数超出其最大值。

`Py_INCREF`和`Py_DECREF`宏在Python的C扩展中广泛使用，它们允许开发者在不直接操作对象内部`ob_refcnt`字段的情况下，安全地修改对象的引用计数。

`Py_CLEAR`宏用于将对象的引用计数减一并将对象指针设置为NULL，这是在清理对象时的一种安全做法，以避免在对象的析构函数中使用悬挂指针。

`Py_XINCREF`和`Py_XDECREF`是`Py_INCREF`和`Py_DECREF`的安全版本，它们在对象指针可能为NULL时使用。

`Py_NewRef`和`Py_XNewRef`函数用于创建对象的新强引用，即增加对象的引用计数并返回对象本身。

refcount是CPython内存管理的关键部分，它确保了对象的生命周期得到妥善管理，防止了内存泄漏和野指针的问题。

```c
/*
不朽化：

以下根据引用计数字段里可用的位数指定不朽化策略。所有策略都是向后兼容的，但是特定的引用计数值或不朽化检查可能会根据对标系统底层实现的专门化而改变。

适当销毁不朽实例需要区分静态分配的不朽实例和运行时提升为不朽的实例，这些是唯一需要在运行时最终化时清理的实例。
*/
```

对上面的段落明确: 这是在描述当Python的引用计数所使用的存储空间太大无法表示为常规计数时所使用的方法 —— 为了使对象为”不朽“ (immortal)，意味着这一对象会保持不被垃圾收集器销毁。这常发生在对象无需再被管理生命周期，例如特权模式常量，或者因为某些设计而知道会被全局永远使用的对象。

紧接着的注释部分指出不同策略会被使用到，在既有的引用计数字段里仅存在 32或者更少的位：

```c
#if SIZEOF_VOID_P > 4
// 在 64 位及以上系统中，通过设置引用计数字段的下 32 位为 0xFFFFFFFF 来标记对象为不朽。
// 在这里用下 32 位具有向后兼容性，允许未更新 Py_INCREF 和 Py_DECREF 检查的 C 扩展安全增减对象引用计数。
#else
// 在 32 位系统中，通过设置引用计数字段的低 30 位为 0x3FFFFFFF 来标记一个对象为不朽。
#endif
```

首先区分是32位系统还是更大的系统（典型为64位系统），应为这决定了多少位用于标识一个对象为不朽。

局部且针对没有 Python 所典型的全局解释器锁 (GIL) 特定编译版本的代码（即 `Py_GIL_DISABLED` 定义），它定义了另外的宏 `_Py_IMMORTAL_REFCNT_LOCAL`，它始终是 32 位的，并且使用一个不同字段 `ob_ref_local` 指向不朽对象。

每个下面的代码片段定义了一些宏或者函数，在下面简单概述其目的和使用场景：

- `Py_REFCNT(ob)`: 返回变量 `ob` 引用计数。
- `Py_SET_REFCNT(ob, refcnt)`: 指定变量 `ob` 新的引用计数是 `refcnt`。
- `Py_INCREF(ob)`: 增加对象 `ob` 的引用计数。
- `Py_DECREF(ob)`: 减少对象 `ob` 的引用计数。如果引用计数到达零，则对象将被销毁（调用对象的 deallocator）。
- `Py_CLEAR(op)`: 像 `Py_DECREF()`，但在降引用计数之前设 `op` 为 `NULL`。这可以用在容器对象代表的清除他们持有的内对象的情况复杂使和销毁的代码中，安全地清理指针。
- `Py_XINCREF(PyObject *op)`: 类似 `Py_INCREF()`，但 `op` 可能是 `NULL` 。
- `Py_XDECREF(PyObject *op)`: 类似 `Py_DECREF()`，但是 `op` 可能是 `NULL`。
- `Py_NewRef(PyObject* obj)` 和 `Py_XNewRef(PyObject* obj)`：创建给定对象的一个新的强引用，分别用于 `obj` 非 `NULL` 与可能为 `NULL` 的场景。